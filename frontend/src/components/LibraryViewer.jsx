import React, { useState, useEffect } from 'react';
import { Box, Typography, Table, TableBody, TableCell, TableContainer, TableHead, TableRow, Paper, CircularProgress, IconButton, Collapse, Link, Tooltip, Select, MenuItem, FormControl, InputLabel } from '@mui/material';
import { DeleteForever as DeleteForeverIcon, ExpandMore as ExpandMoreIcon, ChevronRight as ChevronRightIcon, PlaylistAdd as PlaylistAddIcon, Label as LabelIcon } from '@mui/icons-material';
import MediaEditor from './MediaEditor';

const API_URL = 'http://localhost:8000';

function LibraryViewer({ refreshTrigger, onUpdate }) {
    const [media, setMedia] = useState([]);
    const [isLoading, setIsLoading] = useState(true);
    const [selectedMedia, setSelectedMedia] = useState(null);
    const [isEditorOpen, setIsEditorOpen] = useState(false);
    const [expandedShows, setExpandedShows] = useState({});
    const [expandedSeasons, setExpandedSeasons] = useState({});
    const [allChannels, setAllChannels] = useState([]);
    const [selectedChannelId, setSelectedChannelId] = useState('');
    const fetchMediaAndChannels = () => { setIsLoading(true); Promise.all([ fetch(`${API_URL}/api/media`), fetch(`${API_URL}/api/channels`) ]).then(async ([mediaRes, channelsRes]) => { if (!mediaRes.ok || !channelsRes.ok) throw new Error('Failed to fetch data'); const mediaData = await mediaRes.json(); const channelsData = await channelsRes.json(); setMedia(Array.isArray(mediaData) ? mediaData : []); setAllChannels(Array.isArray(channelsData) ? channelsData : []); if (channelsData.length > 0 && !selectedChannelId) { setSelectedChannelId(channelsData[0].id); } }).catch(error => { console.error(error); setMedia([]); setAllChannels([]); }).finally(() => setIsLoading(false)); };
    useEffect(() => { fetchMediaAndChannels(); }, [refreshTrigger]);
    const handleAddToSchedule = (mediaId, event) => { event.stopPropagation(); if (!selectedChannelId) { alert('Please select a channel first.'); return; } fetch(`${API_URL}/api/channels/${selectedChannelId}/schedule/add`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ mediaId }) }).then(res => { if (res.ok) { onUpdate(); } else { alert('Error: Could not add item to schedule.'); } }).catch(err => alert('Error: Could not add item to schedule.')); };
    const handleAddSeasonToSchedule = (episodes, event) => { event.stopPropagation(); if (!selectedChannelId) { alert('Please select a channel first.'); return; } const mediaIds = episodes.map(ep => ep.id); fetch(`${API_URL}/api/channels/${selectedChannelId}/schedule/add-bulk`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ mediaIds }) }).then(res => { if (res.ok) { onUpdate(); } else { alert('Error: Could not add season to schedule.'); } }).catch(err => alert('Error: Could not add season to schedule.')); };
    const handleCategorizeSeasonAsAdBumps = (episodes, event) => { event.stopPropagation(); if (window.confirm('Are you sure you want to re-categorize all episodes in this season as "Ad Bump"?')) { const mediaIds = episodes.map(ep => ep.id); fetch(`${API_URL}/api/media/bulk-update-category`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ mediaIds, category: 'Ad Bump' }) }).then(res => { if (res.ok) { onUpdate(); } else { alert('Error: Could not re-categorize season.'); } }).catch(err => alert('Error: Could not re-categorize season.')); } };
    const handleRowClick = (file) => { setSelectedMedia(file); setIsEditorOpen(true); };
    const handleCloseEditor = () => { setSelectedMedia(null); setIsEditorOpen(false); };
    const handleSaveMedia = (id, data) => { fetch(`${API_URL}/api/media/${id}`, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(data) }).then(() => { fetchMediaAndChannels(); handleCloseEditor(); }); };
    const handleDeleteMedia = (id, event) => { event.stopPropagation(); if (window.confirm('Are you sure?')) { fetch(`${API_URL}/api/media/${id}`, { method: 'DELETE' }).then(() => { fetchMediaAndChannels(); }); } };
    const formatDuration = (seconds) => { if (isNaN(seconds) || seconds === null) return 'N/A'; const date = new Date(seconds * 1000); const h = date.getUTCHours(); const m = date.getUTCMinutes(); const s = date.getUTCSeconds(); return [h,m,s].map(v => v < 10 ? '0' + v : v).filter((v,i) => v !== '00' || i > 0).join(':') || '0:00'; };
    const handleToggleShow = (showName) => setExpandedShows(p => ({ ...p, [showName]: !p[showName] }));
    const handleToggleSeason = (showName, season) => setExpandedSeasons(p => ({ ...p, [`${showName}-${season}`]: !p[`${showName}-${season}`] }));
    const groupedMedia = (media || []).reduce((acc, file) => { const category = file.category || 'Uncategorized'; if (category === 'TV Show' && file.showName) { acc.tvShows = acc.tvShows || {}; acc.tvShows[file.showName] = acc.tvShows[file.showName] || {}; acc.tvShows[file.showName][file.season] = acc.tvShows[file.showName][file.season] || []; acc.tvShows[file.showName][file.season].push(file); } else { acc.otherCategories = acc.otherCategories || {}; acc.otherCategories[category] = acc.otherCategories[category] || []; acc.otherCategories[category].push(file); } return acc; }, { tvShows: {}, otherCategories: {} });
    const renderMediaRow = (file, indent = 4) => ( <TableRow key={file.id} hover onClick={() => handleRowClick(file)} sx={{ cursor: 'pointer' }}> <TableCell sx={{ pl: indent }}> <Box sx={{ display: 'flex', alignItems: 'center' }}> {file.category === 'YouTube' && file.thumbnail && (<img src={file.thumbnail} alt="thumbnail" width="120" style={{ marginRight: '16px', borderRadius: '4px' }} />)} <Box> <Typography variant="body1">{file.title || `Episode ${file.episode}`}</Typography> {file.category === 'YouTube' ? (<Link href={`https://www.youtube.com/watch?v=${file.videoId}`} target="_blank" rel="noopener" onClick={(e) => e.stopPropagation()}>Watch on YouTube</Link>) : (<Typography variant="body2" color="text.secondary">{file.fileName}</Typography>)} </Box> </Box> </TableCell> <TableCell>{file.category}</TableCell> <TableCell align="right">{formatDuration(file.duration)}</TableCell> <TableCell align="center"> <Tooltip title={!selectedChannelId ? "Select a channel first" : "Add to Schedule"}><span><IconButton aria-label="add to schedule" color="primary" onClick={(e) => handleAddToSchedule(file.id, e)} disabled={!selectedChannelId}><PlaylistAddIcon /></IconButton></span></Tooltip> <IconButton aria-label="delete" color="secondary" onClick={(e) => handleDeleteMedia(file.id, e)} title="Remove from library"><DeleteForeverIcon /></IconButton> </TableCell> </TableRow> );
    if (isLoading) return <CircularProgress />;
    return ( <Box> <Box sx={{display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2}}> <Typography variant="h5">Indexed Media</Typography> <FormControl sx={{ minWidth: 250 }} size="small"> <InputLabel>Add to Channel</InputLabel> <Select value={selectedChannelId} label="Add to Channel" onChange={(e) => setSelectedChannelId(e.target.value)}>{allChannels.map(channel => <MenuItem key={channel.id} value={channel.id}>{channel.number} - {channel.name}</MenuItem>)}</Select> </FormControl> </Box> <TableContainer component={Paper}> <Table> <TableHead><TableRow><TableCell sx={{ fontWeight: 'bold' }}>Title</TableCell><TableCell sx={{ fontWeight: 'bold' }}>Category</TableCell><TableCell align="right" sx={{ fontWeight: 'bold' }}>Duration</TableCell><TableCell align="center" sx={{ fontWeight: 'bold' }}>Actions</TableCell></TableRow></TableHead> <TableBody> {Object.entries(groupedMedia.tvShows).sort(([a], [b]) => a.localeCompare(b)).map(([showName, seasons]) => ( <React.Fragment key={showName}> <TableRow sx={{ bgcolor: 'action.hover' }}><TableCell colSpan={4} onClick={() => handleToggleShow(showName)} sx={{ cursor: 'pointer' }}><Box sx={{ display: 'flex', alignItems: 'center' }}>{expandedShows[showName] ? <ExpandMoreIcon /> : <ChevronRightIcon />}<Typography variant="subtitle1" sx={{ ml: 1, fontWeight: 'bold', color: 'primary.main' }}>{showName}</Typography></Box></TableCell></TableRow> <Collapse in={expandedShows[showName]} timeout="auto" unmountOnExit>{Object.entries(seasons).sort(([a], [b]) => parseInt(a) - parseInt(b)).map(([seasonNum, episodes]) => ( <React.Fragment key={`${showName}-${seasonNum}`}> <TableRow sx={{ bgcolor: 'action.selected' }}><TableCell colSpan={4} onClick={() => handleToggleSeason(showName, seasonNum)} sx={{ pl: 4, cursor: 'pointer' }}><Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}><Box sx={{ display: 'flex', alignItems: 'center' }}>{expandedSeasons[`${showName}-${seasonNum}`] ? <ExpandMoreIcon /> : <ChevronRightIcon />}<Typography variant="subtitle2" sx={{ ml: 1, fontWeight: 'bold', color: 'secondary.main' }}>Season {seasonNum}</Typography></Box><Box><Tooltip title="Categorize all as Ad Bumps"><span><IconButton onClick={(e) => handleCategorizeSeasonAsAdBumps(episodes, e)} size="small"><LabelIcon /></IconButton></span></Tooltip><Tooltip title="Add all to schedule"><span><IconButton onClick={(e) => handleAddSeasonToSchedule(episodes, e)} disabled={!selectedChannelId} size="small"><PlaylistAddIcon /></IconButton></span></Tooltip></Box></Box></TableCell></TableRow> <Collapse in={expandedSeasons[`${showName}-${seasonNum}`]} timeout="auto" unmountOnExit>{episodes.sort((a, b) => parseInt(a.episode) - parseInt(b.episode)).map(file => renderMediaRow(file, 8))}</Collapse> </React.Fragment> ))}</Collapse> </React.Fragment> ))} {Object.entries(groupedMedia.otherCategories).sort(([a], [b]) => a.localeCompare(b)).map(([categoryName, files]) => ( <React.Fragment key={categoryName}> <TableRow sx={{ bgcolor: 'action.hover' }}><TableCell colSpan={4}><Typography variant="subtitle1" sx={{ fontWeight: 'bold', color: 'primary.main' }}>{categoryName}</Typography></TableCell></TableRow> {files.map(file => renderMediaRow(file, 4))} </React.Fragment> ))} {(!media || media.length === 0) && !isLoading && (<TableRow><TableCell colSpan={4} align="center"><Typography sx={{ py: 3 }}>Library is empty.</Typography></TableCell></TableRow>)} </TableBody> </Table> </TableContainer> <MediaEditor mediaFile={selectedMedia} open={isEditorOpen} onClose={handleCloseEditor} onSave={handleSaveMedia} /> </Box> );
}
export default LibraryViewer;